""" Input system that copies files and folders from the filesystem """

import logging
import os
import filecmp

from pathlib import Path
from shutil import copytree, copy2

def backup(filesystem_cfg, tmp_dir):
    """ Does the backup with the configuration contained in yaml_cfg """
    logger = logging.getLogger('')

    mappings = {}
    counter = 0

    for path in filesystem_cfg['paths']:
        counter += 1

        folder = folder_name(counter)
        dest = Path(tmp_dir, folder)

        mappings[path] = folder

        logger.info("Backing up path '%s' (mapped to '%s')", path, dest.resolve().as_posix())
        if Path(path).is_file():
            os.makedirs(dest)
            copy2(path, dest)
        else:
            copytree(path, dest)

    return mappings

def folder_name(counter):
    """ Return the name of a folder generated by this plugin given a counter """
    return f"fs{counter}"

def verify(filesystem_cfg, mappings, tmp_dir):
    """ Verifies that the filesystem backup in tmp_dir characterised by mappings is valid,
    checking againts the original paths on the filesystem """
    logger = logging.getLogger('')

    for path in mappings:
        original = Path(path)
        copied = Path(tmp_dir, mappings[path])

        if original.is_dir():
            logger.info("Comparing folder '%s' with folder '%s'",
                        original.as_posix(), copied.as_posix())
            dcmp = filecmp.dircmp(original, copied)
            equal = seems_equal(dcmp)
        else:
            copied_file = Path(copied.as_posix(), original.stem + original.suffix)
            logger.info("Comparing file '%s' with file '%s'",
                        original.as_posix(), copied_file.as_posix())
            equal = filecmp.cmp(original, copied_file, shallow=False)

        if equal:
            logger.info("Done, they seem equal")
        else:
            return False

    return True

def seems_equal(dcmp):
    """ Accepts a dircmp object and recursively checks
    that are files and subdirectories are common """
    subdirs = dcmp.subdirs.values()

    # If there are no more subdirs we reached the base of the recursion
    if not subdirs:
        return (not dcmp.left_only) and (not dcmp.right_only)

    # Otherwise, we have to inspect subdirectories
    res = True
    for subd in subdirs:
        res = res and seems_equal(subd)

    return res and (not dcmp.left_only) and (not dcmp.right_only)
